#!/usr/bin/env bun
/**
 * Build script for SlangLang playground
 * Bundles the compiler for browser use
 * 
 * Keywords are loaded from editor/keywords.json (generated by tools/generate-syntax.js)
 */

import { readFileSync, writeFileSync, copyFileSync, mkdirSync, existsSync, readdirSync } from 'fs';
import { execSync } from 'child_process';
import { join } from 'path';

console.log('üî® Building SlangLang playground...\n');

// Ensure dist directory exists
mkdirSync('./playground/dist', { recursive: true });

// Load keywords from generated JSON (produced by generate-syntax.js)
function loadKeywords() {
  const keywordsPath = './editor/keywords.json';
  
  if (!existsSync(keywordsPath)) {
    console.log('‚ö†Ô∏è  keywords.json not found, running generate-syntax.js...');
    execSync('bun ../tools/generate-syntax.js', { stdio: 'inherit' });
  }
  
  const data = JSON.parse(readFileSync(keywordsPath, 'utf8'));
  return data.all;
}

const keywords = loadKeywords();
console.log(`üìù Loaded ${keywords.length} keywords from editor/keywords.json`);

// Use esbuild for proper IIFE bundling with global name
// This ensures the entry point actually executes
try {
  execSync(
    'npx esbuild ./playground/compiler-browser.js --bundle --format=iife --global-name=SlangLangBundle --platform=browser --outfile=./playground/dist/slanglang.bundle.js',
    { stdio: 'inherit' }
  );
} catch (e) {
  // If esbuild isn't available, try with bun but add manual wrapper
  console.log('esbuild not found, using alternative approach...');
  
  // Build with bun
  await Bun.build({
    entrypoints: ['./playground/compiler-browser.js'],
    outdir: './playground/dist',
    target: 'browser',
    format: 'esm', // ESM auto-executes
    naming: 'slanglang.bundle.js',
    minify: false,
  });
  
  // Wrap in script that works without module type
  let bundle = readFileSync('./playground/dist/slanglang.bundle.js', 'utf8');
  bundle = `(function() {\n${bundle}\n})();`;
  writeFileSync('./playground/dist/slanglang.bundle.js', bundle);
}

console.log('‚úÖ Bundled compiler');

// Copy syntax highlighting files
copyFileSync('./editor/slanglang.hljs.js', './playground/dist/slanglang.hljs.js');
copyFileSync('./editor/slanglang.css', './playground/dist/slanglang.css');

// Copy spec.md for AI context
copyFileSync('./spec.md', './playground/dist/spec.md');

// Validate and concatenate example files for AI context
function validateAndConcatenateExamples() {
  const examplesDir = './examples';
  
  // Get all .slang files from examples directory
  const allFiles = readdirSync(examplesDir);
  const exampleFiles = allFiles
    .filter(file => file.endsWith('.slang'))
    .sort(); // Sort for consistent output
  
  if (exampleFiles.length === 0) {
    console.warn('‚ö†Ô∏è  No .slang files found in examples directory');
    return { content: '', files: [] };
  }
  
  console.log(`\nüìö Found ${exampleFiles.length} example file(s): ${exampleFiles.join(', ')}`);
  
  // Import transpile function for validation
  const transpile = require('../compiler.js');
  
  let examplesContent = '# SlangLang Code Examples\n\n';
  examplesContent += 'These examples demonstrate real SlangLang code patterns and syntax.\n\n';
  examplesContent += '---\n\n';
  
  const validatedFiles = [];
  let hasErrors = false;
  
  for (const file of exampleFiles) {
    const filePath = join(examplesDir, file);
    try {
      const content = readFileSync(filePath, 'utf8');
      
      // Validate by transpiling
      try {
        const jsCode = transpile(content);
        console.log(`  ‚úÖ ${file} - compiled successfully`);
        validatedFiles.push(file);
        
        examplesContent += `## ${file}\n\n`;
        examplesContent += '```slang\n';
        examplesContent += content;
        examplesContent += '\n```\n\n';
        examplesContent += '---\n\n';
      } catch (compileError) {
        console.error(`  ‚ùå ${file} - COMPILATION FAILED`);
        console.error(`     Error: ${compileError.message}`);
        hasErrors = true;
      }
    } catch (readError) {
      console.error(`  ‚ùå ${file} - READ FAILED: ${readError.message}`);
      hasErrors = true;
    }
  }
  
  if (hasErrors) {
    console.error('\n‚ùå Build failed: One or more example files failed validation');
    console.error('   Please fix the errors above or remove invalid examples');
    process.exit(1);
  }
  
  console.log(`\n‚úÖ All ${validatedFiles.length} example file(s) validated successfully`);
  
  return { content: examplesContent, files: validatedFiles };
}

const { content: examplesContent, files: validatedFiles } = validateAndConcatenateExamples();
writeFileSync('./playground/dist/examples.md', examplesContent);
console.log(`‚úÖ Generated examples.md from ${validatedFiles.length} validated example file(s)`);

// Copy config.js for OAuth setup
copyFileSync('./playground/config.js', './playground/dist/config.js');

console.log('‚úÖ Copied syntax highlighting, spec.md, and config.js');

// Process HTML - inject auto-generated keywords
let html = readFileSync('./playground/index.html', 'utf8');

// Replace the placeholder keywords set with auto-generated one
const keywordsJson = JSON.stringify(keywords);
html = html.replace(
  /const keywords = new Set\(\[.*?\]\);.*(?:\/\/.*)?/,
  `const keywords = new Set(${keywordsJson}); // AUTO-GENERATED from lexer.js`
);

writeFileSync('./playground/dist/index.html', html);

console.log('‚úÖ Generated HTML with keywords');

console.log('\nüéâ Playground built successfully!');
console.log('   Open playground/dist/index.html to test locally');
console.log('   Deploy playground/dist/ to Vercel/GitHub Pages');
